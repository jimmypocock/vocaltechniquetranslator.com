<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vocal Technique Translator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      width: 100%;
      max-width: 1000px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #333;
      font-size: 2.5em;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header p {
      color: #666;
      font-size: 1.1em;
    }

    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    .intensity-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .intensity-control label {
      font-weight: 600;
      color: #333;
    }

    .intensity-slider {
      width: 200px;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }

    .intensity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
    }

    .intensity-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
    }

    .intensity-value {
      font-weight: bold;
      color: #667eea;
      font-size: 1.2em;
      min-width: 20px;
    }

    .input-section,
    .output-section {
      margin-bottom: 20px;
    }

    .section-title {
      font-size: 1.2em;
      font-weight: 600;
      color: #333;
      margin-bottom: 10px;
    }

    textarea {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 1em;
      line-height: 1.6;
      resize: vertical;
      font-family: inherit;
      transition: border-color 0.3s;
    }

    textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .output-textarea {
      background-color: #f8f9fa;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      color: #333;
    }

    .examples {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid #e0e0e0;
    }

    .example {
      margin-bottom: 15px;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .example-title {
      font-weight: 600;
      color: #333;
      margin-bottom: 5px;
    }

    .technique-info {
      background-color: #e3f2fd;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border-left: 4px solid #2196f3;
    }

    .technique-info h3 {
      color: #1976d2;
      margin-bottom: 10px;
    }

    .technique-info ul {
      list-style-type: none;
      padding-left: 0;
    }

    .technique-info li {
      margin-bottom: 5px;
      padding-left: 20px;
      position: relative;
    }

    .technique-info li:before {
      content: "â™ª";
      position: absolute;
      left: 0;
      color: #2196f3;
    }

    @media (max-width: 768px) {
      .intensity-control {
        justify-content: space-between;
      }

      .header h1 {
        font-size: 2em;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ðŸŽµ Vocal Technique Translator</h1>
      <p>Transform lyrics for optimal vocal technique and open throat positioning</p>
    </div>

    <div class="technique-info">
      <h3>Balanced Vocal Technique & Readability</h3>
      <ul>
        <li>Conservative transformations maintain lyric readability</li>
        <li>Strategic vowel modifications for vocal flow without over-processing</li>
        <li>Exception dictionary preserves common words naturally</li>
        <li>Syllable breaks only added when beneficial for longer words</li>
        <li>Abbreviations and proper nouns handled appropriately</li>
        <li>Intensity 1-3: Minimal changes, 4-5: Conservative, 6-7: Moderate, 8-10: Full technique</li>
      </ul>
    </div>

    <div class="controls">
      <div class="intensity-control">
        <label for="intensity">Intensity:</label>
        <input type="range" id="intensity" class="intensity-slider" min="1" max="10" value="8">
        <span class="intensity-value" id="intensityValue">8</span>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">Original Lyrics</div>
      <textarea id="lyricsInput" placeholder="Enter your song lyrics here...

Example:
Blue jean baby, L.A. lady
Seamstress for the band
Pretty-eyed, pirate smile
You'll marry a music man"></textarea>
    </div>

    <div class="output-section">
      <div class="section-title">Translated for Vocal Technique</div>
      <textarea id="lyricsOutput" class="output-textarea" readonly
        placeholder="Your translated lyrics will appear here..."></textarea>
    </div>

    <div class="examples">
      <div class="section-title">Improved Readability Examples</div>
      <div class="example">
        <div class="example-title">Conservative Transformations (Intensity 4-5):</div>
        "blue jean baby" â†’ "BLUH JAHN BAH-BAY" | "pretty smile" â†’ "PRIH-TEE SMEHL"
      </div>
      <div class="example">
        <div class="example-title">Moderate Changes (Intensity 6-7):</div>
        "lady" â†’ "LAH-DEE" | "music man" â†’ "MYOO-SIK MAHN" | "dancing" â†’ "DAHN-SING"
      </div>
      <div class="example">
        <div class="example-title">Strategic Syllable Breaks (Intensity 8+):</div>
        "ballerina" â†’ "BAHL-LUH-REH-NAH" | "seamstress" â†’ "SEHM-STRESS"
      </div>
      <div class="example">
        <div class="example-title">Preserved Elements:</div>
        Abbreviations: "L.A." stays "L.A." | Contractions: "you'll" â†’ "YAH-LL"
      </div>
    </div>
  </div>

  <script>
    // Advanced Vocal Technique Translation Engine
    class VocalTranslator {
      constructor() {
        // Exception dictionary for common words
        this.exceptionWords = {
          // Articles & pronouns
          'the': { 1: 'the', 4: 'dhuh', 8: 'da' },
          'a': { 1: 'a', 4: 'uh', 8: 'uh' },
          'an': { 1: 'an', 4: 'uhn', 8: 'uhn' },
          'and': { 1: 'and', 4: 'and', 8: 'and' },
          'of': { 1: 'of', 4: 'uhv', 8: 'uhv' },
          'to': { 1: 'to', 4: 'tuh', 8: 'tuh' },
          'for': { 1: 'for', 4: 'fohr', 8: 'fohr' },
          'with': { 1: 'with', 4: 'wihth', 8: 'wihth' },
          'from': { 1: 'from', 4: 'fruhm', 8: 'fruhm' },
          'in': { 1: 'in', 4: 'ihn', 8: 'ihn' },
          'at': { 1: 'at', 4: 'aht', 8: 'aht' },
          'on': { 1: 'on', 4: 'ahn', 8: 'ahn' },
          'by': { 1: 'by', 4: 'bah', 8: 'bah' },

          // Common verbs and pronouns
          'said': { 1: 'said', 4: 'sed', 8: 'sed' },
          'have': { 1: 'have', 4: 'hav', 8: 'hav' },
          'has': { 1: 'has', 4: 'hahs', 8: 'hahs' },
          'was': { 1: 'was', 4: 'wuhz', 8: 'wuhz' },
          'were': { 1: 'were', 4: 'wuhr', 8: 'wuhr' },
          'been': { 1: 'been', 4: 'bihn', 8: 'bihn' },
          'will': { 1: 'will', 4: 'wihl', 8: 'wihl' },
          'would': { 1: 'would', 4: 'wood', 8: 'wood' },
          'could': { 1: 'could', 4: 'kood', 8: 'kood' },
          'should': { 1: 'should', 4: 'shood', 8: 'shood' },

          'you': { 1: 'you', 4: 'yoo', 8: 'yah' },
          'your': { 1: 'your', 4: 'yohr', 8: 'yohr' },
          'youll': { 1: 'youll', 4: 'yoo-ll', 8: 'yah-ll' },
          'there': { 1: 'there', 4: 'thehr', 8: 'dehr' },
          'their': { 1: 'their', 4: 'thehr', 8: 'dehr' },
          'they': { 1: 'they', 4: 'theh', 8: 'deh' },
          'what': { 1: 'what', 4: 'waht', 8: 'waht' },
          'where': { 1: 'where', 4: 'wehr', 8: 'wehr' },
          'when': { 1: 'when', 4: 'wehn', 8: 'wehn' },

          // Specific to the example lyrics
          'blue': { 1: 'blue', 4: 'bluh', 8: 'bluh' },
          'jean': { 1: 'jean', 4: 'jahn', 8: 'jahn' },
          'baby': { 1: 'baby', 4: 'bah-bay', 8: 'bah-bae' },
          'lady': { 1: 'lady', 4: 'lah-dee', 8: 'lahd-eh' },
          'seamstress': { 1: 'seamstress', 4: 'sehm-stress', 8: 'sehm-stress' },
          'band': { 1: 'band', 4: 'bahnd', 8: 'band' },
          'pretty': { 1: 'pretty', 4: 'prih-tee', 8: 'preh-teh' },
          'pirate': { 1: 'pirate', 4: 'pah-ruht', 8: 'pah-ruht' },
          'smile': { 1: 'smile', 4: 'smehl', 8: 'smehl' },
          'eyed': { 1: 'eyed', 4: 'ahed', 8: 'aed' },
          'marry': { 1: 'marry', 4: 'mahr-ee', 8: 'mahr-eh' },
          'music': { 1: 'music', 4: 'myoo-sik', 8: 'myuh-suhk' },
          'man': { 1: 'man', 4: 'mahn', 8: 'mahn' },
          'seen': { 1: 'seen', 4: 'sehn', 8: 'sehn' },
          'her': { 1: 'her', 4: 'hehr', 8: 'hehr' },
          'dancing': { 1: 'dancing', 4: 'dahn-sing', 8: 'dahn-sehn' },
          'sand': { 1: 'sand', 4: 'sahnd', 8: 'sand' },
          'ballerina': { 1: 'ballerina', 4: 'bahl-luhr-eenah', 8: 'bahl-luh-reh-nah' },
          'mustve': { 1: 'mustve', 4: 'muht-ve', 8: 'muht-ve' },

          // Contractions
          'youll': { 1: 'youll', 4: 'yoo-ll', 8: 'yah-ll' },
          'well': { 1: 'well', 4: 'weh-ll', 8: 'weh-ll' },
          'ill': { 1: 'ill', 4: 'ah-ll', 8: 'ah-ll' },
          'cant': { 1: 'cant', 4: 'kahnt', 8: 'kahnt' },
          'wont': { 1: 'wont', 4: 'wohnt', 8: 'wohnt' },
          'dont': { 1: 'dont', 4: 'dohnt', 8: 'dohnt' },
          'didnt': { 1: 'didnt', 4: 'dih-dnt', 8: 'dih-dnt' },
          'wouldnt': { 1: 'wouldnt', 4: 'wood-nt', 8: 'wood-nt' },
          'couldnt': { 1: 'couldnt', 4: 'kood-nt', 8: 'kood-nt' },
          'shouldnt': { 1: 'shouldnt', 4: 'shood-nt', 8: 'shood-nt' },
          'wouldve': { 1: 'wouldve', 4: 'wood-ve', 8: 'wood-ve' },
          'couldve': { 1: 'couldve', 4: 'kood-ve', 8: 'kood-ve' },
          'shouldve': { 1: 'shouldve', 4: 'shood-ve', 8: 'shood-ve' }
        };

        // Phoneme-based vowel transforms
        this.vowelPhonemes = {
          // Monophthongs
          'i': { 1: 'i', 4: 'eh', 8: 'ae' },        // bit â†’ baet
          'Éª': { 1: 'ih', 4: 'eh', 8: 'ae' },       // bit â†’ baet
          'e': { 1: 'e', 4: 'eh', 8: 'eh' },        // bet â†’ beht
          'É›': { 1: 'eh', 4: 'eh', 8: 'ah' },       // bet â†’ baht
          'Ã¦': { 1: 'a', 4: 'ah', 8: 'ah' },        // bat â†’ baht
          'É™': { 1: 'uh', 4: 'ah', 8: 'ah' },       // about â†’ ahbaht
          'ÊŒ': { 1: 'uh', 4: 'ah', 8: 'ah' },       // but â†’ baht
          'É‘': { 1: 'ah', 4: 'ah', 8: 'ah' },       // bot â†’ baht
          'É”': { 1: 'aw', 4: 'oh', 8: 'ah' },       // bought â†’ baht
          'o': { 1: 'o', 4: 'oh', 8: 'ah' },        // boat â†’ baht
          'ÊŠ': { 1: 'oo', 4: 'uh', 8: 'ah' },       // book â†’ bahk
          'u': { 1: 'oo', 4: 'oo', 8: 'ah' },       // boot â†’ baht

          // Diphthongs - emphasize first vowel
          'aÉª': { 1: 'ai', 4: 'ah', 8: 'ah' },      // bite â†’ baht
          'aÊŠ': { 1: 'ow', 4: 'ah', 8: 'ah' },      // bout â†’ baht
          'É”Éª': { 1: 'oy', 4: 'oh', 8: 'ah' },      // boy â†’ bah
          'eÉª': { 1: 'ay', 4: 'eh', 8: 'ae' },      // bait â†’ baeht
          'oÊŠ': { 1: 'oh', 4: 'oh', 8: 'ah' }       // boat â†’ baht
        };

        // Context-sensitive consonant rules
        this.consonantRules = {
          't': {
            syllableInitial: { 1: 't', 4: 't', 8: 'd' },
            intervocalic: { 1: 't', 4: 'd', 8: 'd' },
            syllableFinal: { 1: 't', 4: 'd', 8: '' },
            beforeConsonant: { 1: 't', 4: 'd', 8: 'd' }
          },
          'k': {
            syllableInitial: { 1: 'k', 4: 'g', 8: 'g' },
            intervocalic: { 1: 'k', 4: 'g', 8: 'g' },
            syllableFinal: { 1: 'k', 4: 'g', 8: 'g' }
          },
          'p': {
            syllableInitial: { 1: 'p', 4: 'b', 8: 'b' },
            intervocalic: { 1: 'p', 4: 'b', 8: 'b' },
            syllableFinal: { 1: 'p', 4: 'b', 8: 'b' }
          },
          'f': {
            syllableInitial: { 1: 'f', 4: 'v', 8: 'v' },
            intervocalic: { 1: 'f', 4: 'v', 8: 'v' },
            syllableFinal: { 1: 'f', 4: 'v', 8: 'v' }
          }
        };

        // Morphological patterns
        this.morphemePatterns = {
          suffixes: {
            'ing': { 1: 'ing', 4: 'eeng', 8: 'ahng' },
            'ed': { 1: 'ed', 4: 'd', 8: 'd' },
            'er': { 1: 'er', 4: 'uhr', 8: 'ahr' },
            'est': { 1: 'est', 4: 'ehst', 8: 'ahst' },
            'ly': { 1: 'ly', 4: 'lee', 8: 'lae' },
            'tion': { 1: 'tion', 4: 'shuhn', 8: 'shahn' },
            'sion': { 1: 'sion', 4: 'zhuhn', 8: 'zhahn' },
            'ness': { 1: 'ness', 4: 'nehs', 8: 'nahs' },
            'ment': { 1: 'ment', 4: 'mehnt', 8: 'mahnt' },
            'ful': { 1: 'ful', 4: 'fool', 8: 'fahl' },
            'less': { 1: 'less', 4: 'lehs', 8: 'lahs' },
            'able': { 1: 'able', 4: 'uhbuhl', 8: 'ahbahl' },
            'ible': { 1: 'ible', 4: 'uhbuhl', 8: 'ahbahl' }
          },
          prefixes: {
            'un': { 1: 'un', 4: 'uhn', 8: 'ahn' },
            're': { 1: 're', 4: 'ree', 8: 'rae' },
            'pre': { 1: 'pre', 4: 'pree', 8: 'brae' },
            'dis': { 1: 'dis', 4: 'dihs', 8: 'dahs' },
            'over': { 1: 'over', 4: 'oh-vuhr', 8: 'ah-vahr' }
          }
        };

        // Common phonetic patterns
        this.phoneticPatterns = {
          'ph': 'f',
          'gh': '', // usually silent in modern English
          'ch': 'ch',
          'th': 'th',
          'sh': 'sh',
          'wh': 'w',
          'ck': 'k',
          'dge': 'j',
          'tch': 'ch'
        };

        // Vowel patterns with context
        this.vowelPatterns = {
          'ee': { sound: 'i', context: 'long_e' },
          'ea': { sound: 'i', context: 'long_e' },
          'ie': { sound: 'i', context: 'long_e' },
          'oo': { sound: 'u', context: 'long_u' },
          'ou': { sound: 'aÊŠ', context: 'diphthong' },
          'ow': { sound: 'aÊŠ', context: 'diphthong' },
          'ai': { sound: 'eÉª', context: 'diphthong' },
          'ay': { sound: 'eÉª', context: 'diphthong' },
          'ey': { sound: 'eÉª', context: 'diphthong' },
          'oi': { sound: 'É”Éª', context: 'diphthong' },
          'oy': { sound: 'É”Éª', context: 'diphthong' },
          'au': { sound: 'É”', context: 'long_o' },
          'aw': { sound: 'É”', context: 'long_o' }
        };
      }

      // Syllable boundary detection with better error handling
      syllabify(word) {
        if (!word || word.length === 0) return [];
        if (word.length <= 2) return [word];

        const vowels = 'aeiouAEIOU';
        const consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ';

        // Find vowel positions
        const vowelPositions = [];
        for (let i = 0; i < word.length; i++) {
          if (vowels.includes(word[i])) {
            vowelPositions.push(i);
          }
        }

        // If no vowels or only one vowel, return as single syllable
        if (vowelPositions.length <= 1) return [word];

        const syllables = [];
        let start = 0;

        for (let i = 0; i < vowelPositions.length - 1; i++) {
          const currentVowel = vowelPositions[i];
          const nextVowel = vowelPositions[i + 1];

          // Find consonants between vowels
          let consonantStart = currentVowel + 1;
          while (consonantStart < nextVowel && !consonants.includes(word[consonantStart])) {
            consonantStart++;
          }

          let consonantEnd = consonantStart;
          while (consonantEnd < nextVowel && consonants.includes(word[consonantEnd])) {
            consonantEnd++;
          }

          const consonantCluster = word.slice(consonantStart, consonantEnd);
          let boundary;

          if (consonantCluster.length === 0) {
            // No consonants between vowels - split after first vowel
            boundary = currentVowel + 1;
          } else if (consonantCluster.length === 1) {
            // Single consonant - goes to second syllable
            boundary = consonantStart;
          } else if (consonantCluster.length === 2) {
            // Two consonants - split between them
            boundary = consonantStart + 1;
          } else {
            // Three or more consonants - split after first
            boundary = consonantStart + 1;
          }

          // Ensure boundary is within word bounds
          boundary = Math.max(start, Math.min(boundary, word.length));

          if (boundary > start) {
            syllables.push(word.slice(start, boundary));
            start = boundary;
          }
        }

        // Add final syllable
        if (start < word.length) {
          syllables.push(word.slice(start));
        }

        return syllables.filter(s => s && s.length > 0);
      }

      // Identify morphemes with better error handling
      analyzeMorphology(word) {
        if (!word || word.length === 0) {
          return { prefix: '', root: '', suffix: '', compound: false };
        }

        const lowerWord = word.toLowerCase();
        const result = {
          prefix: '',
          root: word,
          suffix: '',
          compound: false
        };

        // Check for prefixes
        for (const prefix of Object.keys(this.morphemePatterns.prefixes)) {
          if (lowerWord.startsWith(prefix) && lowerWord.length > prefix.length + 2) {
            result.prefix = word.slice(0, prefix.length);
            result.root = word.slice(prefix.length);
            break;
          }
        }

        // Check for suffixes (on the root, not the whole word if we found a prefix)
        const rootToCheck = result.root.toLowerCase();
        for (const suffix of Object.keys(this.morphemePatterns.suffixes)) {
          if (rootToCheck.endsWith(suffix) && rootToCheck.length > suffix.length + 2) {
            const suffixStart = result.root.length - suffix.length;
            result.suffix = result.root.slice(suffixStart);
            result.root = result.root.slice(0, suffixStart);
            break;
          }
        }

        return result;
      }

      // Convert common letter patterns to phonemes with error handling
      normalizePhonetics(word) {
        if (!word) return '';
        let normalized = word.toLowerCase();

        // Apply phonetic pattern replacements
        for (const [pattern, replacement] of Object.entries(this.phoneticPatterns)) {
          try {
            normalized = normalized.replace(new RegExp(pattern, 'g'), replacement);
          } catch (e) {
            // Skip problematic patterns
            continue;
          }
        }

        // Handle silent letters
        const silentPatterns = {
          'mb$': 'm',     // lamb, thumb
          'ght': 't',     // night, light
          'kn': 'n',      // knife, know
          'wr': 'r',      // write, wrong
          'gn': 'n',      // sign, design
          'bt$': 't',     // debt, doubt
          'sc': 's',      // scene, science
          'ps': 's',      // psalm, psychology
          'rh': 'r'       // rhyme, rhythm
        };

        for (const [pattern, replacement] of Object.entries(silentPatterns)) {
          try {
            normalized = normalized.replace(new RegExp(pattern, 'g'), replacement);
          } catch (e) {
            // Skip problematic patterns
            continue;
          }
        }

        return normalized;
      }

      // Context-sensitive consonant transformation with error handling
      transformConsonantInContext(consonant, position, syllables, syllableIndex, positionInSyllable) {
        if (!consonant || !this.consonantRules[consonant]) {
          return consonant; // Return unchanged if no rule exists
        }

        const rules = this.consonantRules[consonant];
        const intensity = this.getIntensityLevel(this.currentIntensity || 5);
        let context = 'syllableInitial'; // default

        try {
          // Determine context safely
          if (positionInSyllable === 0) {
            context = 'syllableInitial';
          } else if (syllables && syllables[syllableIndex] && positionInSyllable === syllables[syllableIndex].length - 1) {
            context = 'syllableFinal';
          } else if (syllables && syllables[syllableIndex]) {
            // Check if between vowels
            const syllable = syllables[syllableIndex];
            const before = positionInSyllable > 0 ? syllable[positionInSyllable - 1] : '';
            const after = positionInSyllable < syllable.length - 1 ? syllable[positionInSyllable + 1] : '';

            if ('aeiouAEIOU'.includes(before) && 'aeiouAEIOU'.includes(after)) {
              context = 'intervocalic';
            } else if ('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'.includes(after)) {
              context = 'beforeConsonant';
            }
          }
        } catch (e) {
          // If context detection fails, use default
          context = 'syllableInitial';
        }

        const transformation = rules[context] || rules['syllableInitial'] || {};
        return transformation[intensity] || transformation[1] || consonant;
      }

      // Transform vowel based on phonetic context with error handling
      transformVowelPhoneme(vowelPattern, intensity) {
        if (!vowelPattern) return '';

        const level = this.getIntensityLevel(intensity);

        try {
          // Check if it's a recognized vowel pattern
          if (this.vowelPatterns[vowelPattern]) {
            const phoneticInfo = this.vowelPatterns[vowelPattern];
            const phoneme = phoneticInfo.sound;

            if (this.vowelPhonemes[phoneme]) {
              const transform = this.vowelPhonemes[phoneme];
              return transform[level] || transform[1] || vowelPattern;
            }
          }

          // Fallback to single vowel
          if (this.vowelPhonemes[vowelPattern]) {
            const transform = this.vowelPhonemes[vowelPattern];
            return transform[level] || transform[1] || vowelPattern;
          }

          // Simple vowel mapping fallback
          const simpleVowelMap = {
            'a': 'ah', 'e': 'eh', 'i': 'ae', 'o': 'oh', 'u': 'ah'
          };

          if (level >= 4 && simpleVowelMap[vowelPattern]) {
            return simpleVowelMap[vowelPattern];
          }
        } catch (e) {
          // If anything fails, return original
          return vowelPattern;
        }

        return vowelPattern;
      }

      getIntensityLevel(intensity) {
        if (intensity <= 3) return 1;
        if (intensity <= 7) return 4;
        return 8;
      }

      transformMorpheme(morpheme, intensity) {
        if (!morpheme || morpheme.length === 0) return '';

        try {
          // Normalize phonetic patterns first
          const normalized = this.normalizePhonetics(morpheme);

          // Syllabify the morpheme
          const syllables = this.syllabify(normalized);

          // If syllabification failed or returned empty, use simple processing
          if (!syllables || syllables.length === 0) {
            return this.simpleTransform(morpheme, intensity);
          }

          let result = '';

          for (let syllableIndex = 0; syllableIndex < syllables.length; syllableIndex++) {
            const syllable = syllables[syllableIndex];
            if (!syllable || syllable.length === 0) continue;

            let syllableResult = '';

            let i = 0;
            while (i < syllable.length) {
              const char = syllable[i];
              let processed = false;

              // Check for vowel patterns (2+ characters)
              // Try 3-character vowel patterns first
              if (i + 2 < syllable.length) {
                const threeChar = syllable.slice(i, i + 3);
                if (this.vowelPatterns && this.vowelPatterns[threeChar]) {
                  syllableResult += this.transformVowelPhoneme(threeChar, intensity);
                  i += 3;
                  processed = true;
                }
              }

              // Try 2-character vowel patterns
              if (!processed && i + 1 < syllable.length) {
                const twoChar = syllable.slice(i, i + 2);
                if (this.vowelPatterns && this.vowelPatterns[twoChar]) {
                  syllableResult += this.transformVowelPhoneme(twoChar, intensity);
                  i += 2;
                  processed = true;
                }
              }

              // Single character processing
              if (!processed) {
                if ('aeiouAEIOU'.includes(char)) {
                  // Single vowel
                  syllableResult += this.transformVowelPhoneme(char.toLowerCase(), intensity);
                } else if ('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'.includes(char)) {
                  // Consonant with context
                  const transformed = this.transformConsonantInContext(
                    char.toLowerCase(),
                    i,
                    syllables,
                    syllableIndex,
                    syllableResult.length
                  );
                  syllableResult += transformed;
                } else {
                  // Keep other characters as-is
                  syllableResult += char;
                }
                i++;
              }
            }

            result += syllableResult;

            // Add syllable separator for multi-syllable words at high intensity
            if (intensity >= 8 && syllables.length > 1 && syllableIndex < syllables.length - 1) {
              result += '-';
            }
          }

          return result;

        } catch (error) {
          // If anything fails, fall back to simple transformation
          console.warn('Advanced transformation failed, using simple transform:', error);
          return this.simpleTransform(morpheme, intensity);
        }
      }

      // Simple fallback transformation method - more conservative
      simpleTransform(word, intensity) {
        if (!word) return '';

        let result = word.toLowerCase();
        const level = this.getIntensityLevel(intensity);

        // Very conservative transformations
        if (level >= 4) {
          // Only the most basic vowel changes
          result = result.replace(/ee/g, 'eh');
          result = result.replace(/ea/g, 'eh');
        }

        if (level >= 6) {
          // Single vowels - less aggressive
          result = result.replace(/i(?![aeou])/g, 'ah'); // i but not followed by other vowels
          result = result.replace(/e(?![aeou])/g, 'eh');
        }

        if (level >= 8) {
          // Consonants - very selective
          result = result.replace(/t(?![h])/g, 'd'); // t but not th
        }

        return result;
      }

      translateWord(word, intensity) {
        if (!word || word.trim() === '') return word;

        try {
          this.currentIntensity = intensity; // Store for context-sensitive rules
          const originalWord = word.toLowerCase().trim();

          // 1. Check exception dictionary first (highest priority)
          if (this.exceptionWords && this.exceptionWords[originalWord]) {
            const level = this.getIntensityLevel(intensity);
            const exception = this.exceptionWords[originalWord];
            return (exception[level] || exception[1] || originalWord).toUpperCase();
          }

          // 2. For very short words, use simple processing
          if (originalWord.length <= 2) {
            return this.simpleTransform(originalWord, intensity).toUpperCase();
          }

          // 3. Morphological analysis
          const morphology = this.analyzeMorphology(word);
          let result = '';

          // 4. Handle prefix if present
          if (morphology.prefix) {
            const prefixPattern = this.morphemePatterns.prefixes[morphology.prefix.toLowerCase()];
            if (prefixPattern) {
              const level = this.getIntensityLevel(intensity);
              result += (prefixPattern[level] || prefixPattern[1] || morphology.prefix);
            } else {
              result += this.transformMorpheme(morphology.prefix, intensity);
            }
          }

          // 5. Handle root word
          const rootTransformed = this.transformMorpheme(morphology.root, intensity);
          result += rootTransformed;

          // 6. Handle suffix if present
          if (morphology.suffix) {
            const suffixPattern = this.morphemePatterns.suffixes[morphology.suffix.toLowerCase()];
            if (suffixPattern) {
              const level = this.getIntensityLevel(intensity);
              result += (suffixPattern[level] || suffixPattern[1] || morphology.suffix);
            } else {
              result += this.transformMorpheme(morphology.suffix, intensity);
            }
          }

          // Clean up result and return
          const finalResult = result || originalWord;
          return finalResult.toUpperCase();

        } catch (error) {
          // If anything fails, fall back to simple transformation
          console.warn('Word transformation failed, using fallback:', error);
          return this.simpleTransform(word, intensity).toUpperCase();
        }
      }

      translateLyrics(lyrics, intensity) {
        if (!lyrics || lyrics.trim() === '') return '';

        const lines = lyrics.split('\n');
        const translatedLines = lines.map(line => {
          // Handle contractions and special cases first
          let processedLine = line
            .replace(/you'll/gi, 'youll')  // Handle contractions
            .replace(/we'll/gi, 'well')
            .replace(/i'll/gi, 'ill')
            .replace(/can't/gi, 'cant')
            .replace(/won't/gi, 'wont')
            .replace(/don't/gi, 'dont')
            .replace(/didn't/gi, 'didnt')
            .replace(/wouldn't/gi, 'wouldnt')
            .replace(/couldn't/gi, 'couldnt')
            .replace(/shouldn't/gi, 'shouldnt')
            .replace(/must've/gi, 'mustve')
            .replace(/would've/gi, 'wouldve')
            .replace(/could've/gi, 'couldve')
            .replace(/should've/gi, 'shouldve');

          // Split on word boundaries but preserve punctuation and spacing
          const words = processedLine.split(/(\s+|[^\w\s'-])/);
          const translatedWords = words.map(word => {
            // Only translate actual words (not punctuation or spaces)
            if (/^[\w'-]+$/.test(word)) {
              return this.translateWord(word, intensity);
            }
            return word;
          });
          return translatedWords.join('');
        });

        return translatedLines.join('\n');
      }
    }

    // Initialize translator
    const translator = new VocalTranslator();

    // Update intensity display
    const intensitySlider = document.getElementById('intensity');
    const intensityValue = document.getElementById('intensityValue');

    intensitySlider.addEventListener('input', function () {
      intensityValue.textContent = this.value;
    });

    // Auto-translate on input change (with debounce)
    let timeoutId;

    function translateLyrics() {
      const input = document.getElementById('lyricsInput').value;
      const intensity = parseInt(document.getElementById('intensity').value);
      const output = document.getElementById('lyricsOutput');

      if (!input.trim()) {
        output.value = '';
        return;
      }

      const translated = translator.translateLyrics(input, intensity);
      output.value = translated;
    }

    document.getElementById('lyricsInput').addEventListener('input', function () {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(translateLyrics, 300);
    });

    intensitySlider.addEventListener('input', function () {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(translateLyrics, 100);
    });

    // Initial translation on page load if there's content
    window.addEventListener('load', function () {
      const input = document.getElementById('lyricsInput').value;
      if (input.trim()) {
        translateLyrics();
      }
    });
  </script>
</body>

</html>